CF::MaxNatural = 4294967296

//sequence used to control order of transformations

seqLen = 32

seq = randint( 2^seqLen )

natural nextIdx ( natural n ) = mod ( n+1, seqLen )

natural seqBit ( natural n ) = bitand ( seq, 2^mod( n, seqLen ) )

//distance from the origin to the leg of a right-angle triangle in order
//for the origin to be the centroid of the triangle
ra_ratio = ( sqrt ( 2 ) / 4 ) / tan ( 45 )


startshape START []

shape START
{
	SQ_A ( 7, 0 ) [ b 0.5 sat 0.5 ]
}

/*
Each shape has 4 stages:
   A - Check n > 0 and advance sequence idx or draw final shape
   B - Transform shape according to sequence.
       Note:  Shapes have different rules for which transforms are allowed.
   D - Create child shapes.
*/

/****************************************************************************
 * SQ - Square
 ***************************************************************************/

shape SQ_A ( natural n, natural seqIdx )
{
	if ( n > 0 )
	{
		SQ_B ( n, nextIdx ( seqIdx ) ) []
	}
	else
	{
		SQUARE [ s 0.95 ]
	}
}

shape SQ_B ( natural n, natural seqIdx )
{
	R = 90*seqBit(seqIdx)

	H1 =  seqBit( seqIdx )
	H2 = -1*seqBit( seqIdx+1 )

	H = ( H1+H2 ) * 3

	S1 = seqBit ( 4  )
	S2 = seqBit ( 10 )
	
	S = ( ( S1 * -1 ) + S2 ) * 0.1

	B1 = seqBit ( 6 )
	B2 = seqBit ( 8 )
	
	B = ( ( B1 * -1 ) + B2 ) * 0.1

	SQ_C ( n, seqIdx ) [ ] // r R h H sat S b B ]
}


shape SQ_C ( natural n, natural seqIdx )
rule 
{
	r1 = -0.5 + ra_ratio
	r2 =  0.5 - ra_ratio

	RA_A  ( n--1, seqIdx ) [ x r1 y r2]
	RA_A  ( n--1, seqIdx ) [ x r2 y r1 r 180 ]
}
rule
{
	gridSize = randint ( 4 ) + 1

	loop i=gridSize [ x ( 1/gridSize ) ]
	{
		loop j=gridSize [ y (1/gridSize) ]
		{
			X = -0.5+(1/(gridSize*2))
			Y = -0.5+(1/(gridSize*2))
			SQ_A ( n--gridSize, seqIdx ) [ x X y Y s (1/gridSize) ]
		}
	}
}

/****************************************************************************
 * RA - Right Angle Triangle
 ***************************************************************************/

shape RA_A ( natural n, natural seqIdx )
{
	if ( n > 0 )
	{
		RA_B ( n, nextIdx ( seqIdx ) ) []
	}
	else
	{
		RIGHT_ANGLE [ s 0.95 ]
	}
}

shape RA_B ( natural n, natural seqIdx )
{
	F = 45*seqBit(seqIdx)

	H1 =  seqBit( seqIdx )
	H2 = -1*seqBit( seqIdx+1 )

	H = ( H1+H2 ) * 3

	S1 = seqBit ( 4  )
	S2 = seqBit ( 10 )
	
	S = ( ( S1 * -1 ) + S2 ) * 0.1

	B1 = seqBit ( 6 )
	B2 = seqBit ( 8 )
	
	B = ( ( B1 * -1 ) + B2 ) * 0.1

	RA_C ( n, seqIdx ) []// flip F h H sat S b B ]
}

shape RA_C ( natural n, natural seqIdx )
{
	sX = -1 * ( 0.25 - (1-ra_ratio) ) - 0.5
	sY = ( 0.25 - (1-ra_ratio) ) + 0.5
	
	SQ_A  ( n--1, seqIdx ) [ s 0.5 x sX y sY ]

	RA_A  ( n--1, seqIdx ) [ b 1 sat 1 x (0.5-(ra_ratio/2)) y (ra_ratio/2) s 0.5 ]

	RA_A  ( n--1, seqIdx )[ b 1 sat 1 x -(ra_ratio/2) y (-0.5+(ra_ratio/2)) s 0.5 ]

}


//vertex points for unit right angle
ra_x1 = -1 * ra_ratio
ra_y1 = -1 - ra_x1

path RIGHT_ANGLE
{
	MOVETO ( ra_x1, ra_y1 )

	LINETO (   ra_x1, ra_y1+1 )
	LINETO ( ra_x1+1, ra_y1+1 )

	CLOSEPOLY ()

	FILL  () []
}
